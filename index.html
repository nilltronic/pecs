<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>PECS Card Creator â€” Suggestions + Full PDF</title>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
  /* Add modal styling */
  #editModal {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5);
    justify-content: center;
    align-items: center;
    z-index: 3000;
  }
  #editModal .modal-content {
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    max-width: 400px;
    width: 90%;
  }
  #editModal input, #editModal button {
    margin: 6px 0;
    padding: 8px;
    width: 100%;
  }
  #editModal img {
    max-width: 100%;
    height: auto;
    margin: 8px 0;
    display: block;
  }
</style>

</head>
<body>
  <h1>PECS Card Creator</h1>

  <div class="row">
    <div class="inputWrap">
      <input type="text" id="cardText" placeholder="Enter card text" style="width:260px;">
      <div id="suggestions" aria-hidden="true"></div>
    </div>

    <input type="button" value="Choose Image" onclick="document.getElementById('cardImage').click();" />
    <input type="file" style="display:none;" id="cardImage" name="cardImage"/>

    <button onclick="addCard()">Add Card</button>
    <button onclick="generatePDF()">Generate PDF</button>
    <button onclick="clearCards()">Clear</button>

    <label for="cardColor">Text color:</label>
    <input type="color" id="cardColor" value="#000000">
    
    <label>
      <input type="checkbox" id="stackingToggle" checked>
      Use stacking tabs
    </label>
  </div>

  <h3>Card in Progress</h3>
  <div id="tempPreview"></div>

  <h3>Added Cards</h3>
  <div id="preview"></div>

  <h3>Sample Images</h3>
  <div id="sampleImages">
    <!-- Keep these in your images/ folder -->
    <img src="images/yes.png" alt="Yes" onclick="useSampleImage(this)">
    <img src="images/no.png" alt="No" onclick="useSampleImage(this)">
    <img src="images/red.png" alt="Red" onclick="useSampleImage(this)">
    <img src="images/orange.png" alt="Orange" onclick="useSampleImage(this)">
    <img src="images/yellow.png" alt="Yellow" onclick="useSampleImage(this)">
    <img src="images/green.png" alt="Green" onclick="useSampleImage(this)">
    <img src="images/blue.png" alt="Blue" onclick="useSampleImage(this)">
    <img src="images/purple.png" alt="Purple" onclick="useSampleImage(this)">
    <img src="images/toilet.png" alt="Toilet" onclick="useSampleImage(this)">
    <img src="images/drink.png" alt="Drink" onclick="useSampleImage(this)">
    <img src="images/snack.png" alt="Snack" onclick="useSampleImage(this)">
    <img src="images/wash.png" alt="Wash" onclick="useSampleImage(this)">
    <img src="images/home.png" alt="Home" onclick="useSampleImage(this)">
    <img src="images/tidy.png" alt="Tidy" onclick="useSampleImage(this)">
    <img src="images/line.png" alt="Line" onclick="useSampleImage(this)">
    <img src="images/stop.png" alt="Stop" onclick="useSampleImage(this)">
    <img src="images/sit.png" alt="Sit" onclick="useSampleImage(this)">
  </div>
  #sampleImages img {
  width: 80px;           /* Keeps them thumbnail size */
  height: auto;          /* Preserve aspect ratio */
  margin: 5px;
  cursor: pointer;
  border: 1px solid #ccc;
  border-radius: 4px;
  object-fit: contain;   /* Keeps odd-shaped images tidy */
}
#sampleImages img:hover {
  border-color: #000;
}


  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script>
  const { jsPDF } = window.jspdf;

  // ---- data structures ----
  const cards = [];               // added cards
  let selectedSampleImage = null; // chosen (but not added) sample image
  let tempPreviewImage = null;    // what's displayed in the "Card in Progress"

  // Improved symbol library: each entry has a primary name and keywords array
  // Add synonyms/aliases in the keywords array (lowercase).
  const symbolLibrary = [
    { name: "Red", src: "images/red.png", keywords: ["red","colour red","color red"] },
    { name: "Orange", src: "images/orange.png", keywords: ["orange"] },
    { name: "Yellow", src: "images/yellow.png", keywords: ["yellow"] },
    { name: "Green", src: "images/green.png", keywords: ["green"] },
    { name: "Blue", src: "images/blue.png", keywords: ["blue"] },
    { name: "Purple", src: "images/purple.png", keywords: ["purple"] },
    { name: "Yes", src: "images/yes.png", keywords: ["yes","affirm","ok"] },
    { name: "No", src: "images/no.png", keywords: ["no","not"] },
    { name: "Drink", src: "images/drink.png", keywords: ["drink","drink water","cup"] },
    { name: "Snack", src: "images/snack.png", keywords: ["snack","food"] },
    { name: "Toilet", src: "images/toilet.png", keywords: ["toilet","loo","bathroom","toilette"] },
    { name: "Wash", src: "images/wash.png", keywords: ["wash","wash hands","sink"] },
    { name: "Home", src: "images/home.png", keywords: ["home","house"] },
    { name: "Tidy", src: "images/tidy.png", keywords: ["tidy","clean","clean up"] },
    { name: "Line", src: "images/line.png", keywords: ["line","line up"] },
    { name: "Stop", src: "images/stop.png", keywords: ["stop","don't","wait"] },
    { name: "Sit", src: "images/sit.png", keywords: ["sit","sit down","crosslegged"] }
    // add more entries here and don't forget a comma
  ];

  // ---- UI hooks ----
  const cardTextInput = document.getElementById('cardText');
  const suggestionsEl = document.getElementById('suggestions');
  const sampleImagesContainer = document.getElementById('sampleImages');
  const tempPreviewEl = document.getElementById('tempPreview');

  // update suggestions as user types
  cardTextInput.addEventListener('input', onTextInput);
  cardTextInput.addEventListener('focus', onTextInput);

  // hide suggestions if clicking outside
  document.addEventListener('click', (e) => {
    if (!suggestionsEl.contains(e.target) && e.target !== cardTextInput) {
      hideSuggestions();
    }
  });

  // When user chooses a sample image by clicking the thumbnail
  function useSampleImage(imgEl) {
    selectedSampleImage = imgEl.src;
    tempPreviewImage = imgEl.src;
    highlightSample(imgEl.src);
    updateTempPreview();
  }

    // Enable drag & drop reordering of added cards
new Sortable(document.getElementById('preview'), {
  animation: 150,
  ghostClass: 'sortable-ghost',
  chosenClass: 'sortable-chosen',
  dragClass: 'sortable-drag',
  onEnd: function (evt) {
    // Update the cards[] array to reflect new order
    const [moved] = cards.splice(evt.oldIndex, 1);
    cards.splice(evt.newIndex, 0, moved);
  }
});

let editIndex = null; // which card is being edited

function openEdit(i) {
  editIndex = i;
  const c = cards[i];
  document.getElementById('editText').value = c.text;
  document.getElementById('editColor').value = c.color || "#000000";
  document.getElementById('editImagePreview').src = c.image;
  document.getElementById('editModal').style.display = 'flex';
}

function closeEdit() {
  editIndex = null;
  document.getElementById('editModal').style.display = 'none';
  document.getElementById('editImageUpload').value = '';
}

function saveEdit() {
  if (editIndex === null) return;
  const text = document.getElementById('editText').value.trim();
  const color = document.getElementById('editColor').value;
  const imgFile = document.getElementById('editImageUpload').files[0];

  if (imgFile) {
    const reader = new FileReader();
    reader.onloadend = () => {
      cards[editIndex] = { text, color, image: reader.result };
      renderPreview();
      closeEdit();
    };
    reader.readAsDataURL(imgFile);
  } else {
    cards[editIndex] = { text, color, image: cards[editIndex].image };
    renderPreview();
    closeEdit();
  }
}


  // highlight a sample image in the gallery by src
  function highlightSample(src) {
    document.querySelectorAll('#sampleImages img').forEach(img => {
      img.style.borderColor = (img.src === src) ? '#007bff' : '#ccc';
    });
  }

  // When user chooses file upload, prepare live preview
  document.getElementById('cardImage').addEventListener('change', function() {
    const f = this.files && this.files[0];
    if (!f) return;
    selectedSampleImage = null; // file upload takes priority
    const reader = new FileReader();
    reader.onloadend = () => {
      tempPreviewImage = reader.result;
      highlightSample(null);
      updateTempPreview();
    };
    reader.readAsDataURL(f);
  });

  // show/hide suggestions
  function hideSuggestions(){ suggestionsEl.style.display = 'none'; suggestionsEl.innerHTML = ''; }
  function showSuggestions(){ suggestionsEl.style.display = 'block'; }

  // input handler -> create suggestion list
  function onTextInput(){
    const q = (cardTextInput.value || '').toLowerCase().trim();
    if (!q) { hideSuggestions(); updateTempPreview(); return; }

    const matches = symbolLibrary.filter(item => {
      // match primary name or any keyword
      if (item.name && item.name.toLowerCase().includes(q)) return true;
      return item.keywords && item.keywords.some(k => k.includes(q));
    });

    if (matches.length === 0) { hideSuggestions(); updateTempPreview(); return; }

    suggestionsEl.innerHTML = '';
    matches.forEach(item => {
      const row = document.createElement('div');
      row.className = 'item';
      row.innerHTML = `<img src="${item.src}" alt="${escapeHtml(item.name)}"><div class="label">${escapeHtml(item.name)}</div>`;
      row.onclick = () => {
        // Fill text (but do not auto-add). Set the selected sample to this image, show temp preview.
        //cardTextInput.value = item.name;
        if (!cardTextInput.value.trim()) {
        cardTextInput.value = item.name;
        }
        selectedSampleImage = item.src;
        tempPreviewImage = item.src;
        highlightSample(item.src);
        updateTempPreview();
        hideSuggestions();
        cardTextInput.focus();
      };
      suggestionsEl.appendChild(row);
    });
    showSuggestions();
  }

  // --- Live preview for "card in progress" ---
  function updateTempPreview() {
    const text = document.getElementById('cardText').value.trim();
    const color = document.getElementById('cardColor').value;
    const preview = document.getElementById('tempPreview');
    preview.innerHTML = '';

    if (tempPreviewImage) {
      const d = document.createElement('div');
      d.className = 'card';
      d.innerHTML = `
        <div style="width:100px; height:80px; display:flex; align-items:center; justify-content:center; margin:0 auto 6px;">
          <img src="${tempPreviewImage}" alt="preview" style="max-width:100%; max-height:100%;">
        </div>
        <div style="color:${color};"><strong>${escapeHtml(text)}</strong></div>
      `;
      preview.appendChild(d);
    }
  }

  // adds a new card to the list (upload or chosen sample)
  function addCard() {
    const text = document.getElementById('cardText').value.trim();
    const color = document.getElementById('cardColor').value;
    const fileInput = document.getElementById('cardImage');

    if (!text) { alert('Please enter card text.'); return; }

    if (fileInput.files.length > 0) {
      const reader = new FileReader();
      reader.onloadend = () => {
        cards.push({ text, color, image: reader.result });
        resetInputs(); renderPreview();
      };
      reader.readAsDataURL(fileInput.files[0]);
    } else if (selectedSampleImage) {
      cards.push({ text, color, image: selectedSampleImage });
      resetInputs(); renderPreview();
    } else {
      alert('Please choose an image (upload or sample).');
    }
  }

  function resetInputs(){
    document.getElementById('cardText').value = '';
    document.getElementById('cardImage').value = '';
    selectedSampleImage = null;
    tempPreviewImage = null;
    document.getElementById('tempPreview').innerHTML = '';
    highlightSample(null);
    hideSuggestions();
  }

// --- Render added cards ---
  function renderPreview() {
  const preview = document.getElementById('preview');
  preview.innerHTML = '';
  cards.forEach((c, i) => {
    const d = document.createElement('div');
    d.className = 'card';
    d.innerHTML = `
      <div style="width:100px; height:80px; display:flex; align-items:center; justify-content:center; margin:0 auto 6px;">
        <img src="${c.image}" alt="img" style="max-width:100%; max-height:100%;">
      </div>
      <div style="color:${c.color};"><strong>${escapeHtml(c.text)}</strong></div>
      <div style="margin-top:6px;">
        <button onclick="openEdit(${i})">Edit</button>
        <button onclick="removeCard(${i})">Remove</button>
      </div>
    `;
    preview.appendChild(d);
  });
}


    function clearCards(){ 
  if (confirm('Clear all cards?')) { 
    cards.length = 0; 
    renderPreview(); 
  } 
}


  function removeCard(i){ cards.splice(i,1); renderPreview(); }
   // --- Safe escape for HTML ---
  function escapeHtml(s) { 
    return s
      ? s.replace(/[&<>"]/g, c => (
          { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]
        ))
      : ''; 
  }



  // ---- image helpers for PDF: convert to dataURL if needed ----
  function blobToDataURL(blob){
    return new Promise((resolve,reject)=>{
      const reader = new FileReader();
      reader.onloadend = ()=>resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  async function ensureDataURL(src){
    if (!src) throw new Error('No image src');
    if (typeof src === 'string' && src.startsWith('data:')) return src;
    // try fetch -> blob -> dataURL
    try {
      const r = await fetch(src, { mode: 'cors' });
      if (!r.ok) throw new Error('fetch failed ' + r.status);
      const blob = await r.blob();
      return await blobToDataURL(blob);
    } catch (err) {
      // fallback: draw image to canvas (may fail for cross-origin)
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img,0,0);
            resolve(canvas.toDataURL('image/png'));
          } catch(e) { reject(e); }
        };
        img.onerror = (e) => reject(new Error('Could not load image for conversion: ' + src));
        img.src = src;
      });
    }
  }

  function loadImageFromDataURL(dataURL){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=>resolve(img);
      img.onerror = ()=>reject(new Error('image load error'));
      img.src = dataURL;
    });
  }

  // ---- PDF generation (rounded cards, hole, stacking tabs) ----
  async function generatePDF(){
    if (cards.length === 0) { alert('No cards to generate.'); return; }

    const doc = new jsPDF('p','mm','a4');
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();

    const cardWidth = 55;        // mm
    const baseHeight = 60;       // mm (first card)
    const tabOffset = 7;         // mm increase per card (if stacking enabled) //was 5
    const maxTabs = 9;           // resets after 9
    const cornerRadius = 5;      // mm //was 4
    const margin = 6;            // mm spacing between cards & edges
    const holeOffset = 6;        // mm inward from top-left (user wanted ~2mm)//was 2
    const holeRadius = 3;       // mm
    const topSafe = 10;         // mm top safe area inside card
    const imageAboveTextGap = 5; // mm gap between image bottom and text top
    const textBottomMargin = 3;  // mm text offset from bottom (visible when stacked)

    let x = margin, y = margin;
    const useStacking = document.getElementById('stackingToggle').checked;

    for (let i = 0; i < cards.length; i++){
      const c = cards[i];
      const cycleIndex = i % maxTabs;
      const cardH = useStacking ? (baseHeight + cycleIndex * tabOffset) : baseHeight;

      // wrap to next row if doesn't fit horizontally
      if (x + cardWidth > pageW - margin) {
        x = margin;
        y += cardH + margin;
      }

      // new page if necessary
      if (y + cardH > pageH - margin) {
        doc.addPage();
        x = margin;
        y = margin;
      }

      // draw rounded rect border
      doc.setDrawColor(0);
      doc.setLineWidth(0.5);
      // jsPDF roundedRect uses (x,y,w,h,rx,ry,style)
      if (doc.roundedRect) {
        doc.roundedRect(x, y, cardWidth, cardH, cornerRadius, cornerRadius, 'S');
      } else {
        doc.rect(x, y, cardWidth, cardH); // fallback
      }

      // pale grey hole guide moved in by ~2mm
      doc.setDrawColor(180);
      doc.circle(x + holeOffset, y + holeOffset, holeRadius, 'S');
      doc.setDrawColor(0);

      // calculate where the image should be drawn
      const textY = y + cardH - textBottomMargin;
      let imgBottomY = textY - imageAboveTextGap;
      let imgH = Math.min(40, imgBottomY - (y + topSafe)); // prefer 40mm height but fit
      imgH = Math.max(imgH, 2);
      let imgW = cardWidth - 10; // leave small padding on sides

      // draw image (convert local URLs -> dataURL if needed)
      if (c.image) {
        try {
          const dataURL = await ensureDataURL(c.image);
          const imgEl = await loadImageFromDataURL(dataURL);
          const aspect = imgEl.naturalWidth / imgEl.naturalHeight;
          let drawW = imgW, drawH = imgH;
          if (drawW / drawH > aspect) {
            drawW = drawH * aspect;
          } else {
            drawH = drawW / aspect;
          }
          const drawX = x + (cardWidth - drawW) / 2;
          const drawY = imgBottomY - drawH;
          let fmt = 'PNG';
          if (dataURL.startsWith('data:image/jpeg')) fmt = 'JPEG';
          else if (dataURL.startsWith('data:image/webp')) fmt = 'WEBP';
          doc.addImage(dataURL, fmt, drawX, drawY, drawW, drawH);
        } catch (err) {
          console.warn('Image conversion/load failed for card', i, err);
        }
      }

      // draw the text (centered)
      doc.setFontSize(16); //was 14
      doc.setTextColor(c.color || '#000000');
      doc.text(String(c.text || ''), x + cardWidth / 2, textY, { align: 'center' });

      // advance x
      x += cardWidth + margin;
    }

    doc.save('pecs-cards.pdf');
  }
  </script>
  <!-- Edit Modal -->
<div id="editModal">
  <div class="modal-content">
    <h3>Edit Card</h3>
    <input type="text" id="editText" placeholder="Card text">
    <input type="color" id="editColor">
    <img id="editImagePreview" src="" alt="Current Image">
    <input type="file" id="editImageUpload">
    <div style="margin-top:10px; text-align:right;">
      <button onclick="saveEdit()">Save</button>
      <button onclick="closeEdit()">Cancel</button>
    </div>
  </div>
</div>

</body>
</html>






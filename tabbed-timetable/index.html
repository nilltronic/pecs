<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>PECS Tabbed Lanyard Card Creator</title>

  <!-- external libs --> 
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
    input, button { margin: 6px 0; padding: 8px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    /* Previews and cards */
    #preview, #tempPreview { display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }
    .card { border:1px solid #ccc; border-radius:6px; width:120px; padding:6px; text-align:center; background:#fafafa; box-sizing:border-box; }
    .card img { max-width:100%; height:auto; display:block; margin:0 auto 6px; }

    /* Sample images (category gallery) */
    .categoryHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 0;
      margin-top:8px;
    }
    .categoryHeader button { font-size:13px; padding:4px 8px; }

    #sampleImages { margin-top:10px; }
    .sample-row { display:flex; flex-wrap:wrap; gap:8px; }

    #sampleImages img {
      width: 80px;
      height: 80px;
      object-fit: contain;
      background: white;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }

    #cardColor { width: 40px; height: 40px; padding: 0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }

    /* SortableJS visual helpers */
    .sortable-ghost { opacity: 0.4; }
    .sortable-chosen { border: 2px dashed #888; }
    .sortable-drag { transform: rotate(3deg); }

    /* Suggestions dropdown */
    .inputWrap { position:relative; display:inline-block; }
    #suggestions, #editSuggestions {
      position:absolute;
      top: calc(100% + 6px);
      left:0;
      width: 320px;
      background:#fff;
      border:1px solid #ccc;
      border-radius:4px;
      box-shadow:0 2px 6px rgba(0,0,0,0.12);
      max-height:220px;
      overflow:auto;
      z-index:2000;
      display:none;
    }
    #suggestions .item, #editSuggestions .item { display:flex; align-items:center; gap:8px; padding:6px; cursor:pointer; }
    #suggestions .item:hover, #editSuggestions .item:hover { background:#f3f3f3; }
    #suggestions img, #editSuggestions img { width:36px; height:36px; object-fit:contain; border:1px solid #eee; border-radius:3px; }
    #suggestions .label, #editSuggestions .label { font-size:14px; }

    /* Modal styling */
    .modal { display:none; position:fixed; z-index:3000; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; }
    .modal-content { background:#fff; padding:20px; border-radius:8px; width:340px; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
    .modal-content h3 { margin-top:0; }
    .small-thumb { width:48px; height:48px; object-fit:contain; border:1px solid #ccc; margin:2px; cursor:pointer; }

    /* small helpers */
    .muted { color: #666; font-size: 13px; margin-left: 8px; }
    .warning { color: #d63031; font-size: 14px; margin-left: 8px; font-weight: bold; }
  </style>
</head>
<body>

  <h1>PECS Tabbed Lanyard Card Creator</h1>
  <p class="muted">Create up to 10 activity cards with side tabs for easy flipping through your daily schedule.</p>

  <div class="row">
    <div class="inputWrap">
      <input type="text" id="cardText" placeholder="Enter activity name" style="width:320px;">
      <div id="suggestions" aria-hidden="true"></div>
    </div>

    <input type="button" value="Upload Image" onclick="document.getElementById('cardImage').click();" />
    <input type="file" style="display:none;" id="cardImage" name="cardImage" accept="image/*"/>

    <button onclick="addCard()">Add Card</button>
    <button onclick="generatePDF()">Generate PDF</button>
    <button onclick="clearCards()">Clear</button>

    <label for="cardColor">Text color:</label>
    <input type="color" id="cardColor" value="#000000">

    <span id="cardCountWarning" class="warning" style="display:none;">Maximum 10 cards!</span>
  </div>

  <h3>Card in Progress</h3>
  <div id="tempPreview"></div>

  <h3>Added Cards (<span id="cardCount">0</span>/10) - Drag to reorder</h3>
  <div id="preview"></div>

  <h3>Sample Images</h3>

  <!-- Category controls (filter / collapse) -->
  <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
    <button onclick="filterCategory('all')">All</button>
    <button onclick="filterCategory('Colors')">Colors</button>
    <button onclick="filterCategory('Needs')">Needs</button>
    <button onclick="filterCategory('Actions')">Actions</button>
    <button onclick="filterCategory('Places')">Places</button>
    <button onclick="filterCategory('Activities')">Activities</button>
    <button onclick="filterCategory('Behaviours')">Behaviours</button>
    <button onclick="filterCategory('Subjects')">Subjects</button>
  </div>

  <!-- The categorized sample gallery -->
  <div id="sampleImages">
    <!-- Each category container created dynamically by JS from symbolLibrary -->
  </div>

  <!-- Edit modal -->
  <div id="editModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3>Edit Card</h3>
      <input type="text" id="editText" placeholder="Activity name" style="width:100%;">
      <div id="editSuggestions" style="display:none;"></div>

      <label>Text color:</label>
      <input type="color" id="editColor" value="#000000" style="width:48px;"><br>

      <input type="button" value="Choose Image" onclick="document.getElementById('editImage').click();" />
      <input type="file" style="display:none;" id="editImage" name="editImage" accept="image/*"/>

      <div id="editSampleImages" style="margin-top:10px; display:flex; flex-wrap:wrap; gap:6px; max-height:120px; overflow:auto;"></div>

      <div style="margin-top:12px; text-align:right;">
        <button onclick="saveEdit()">Save</button>
        <button onclick="closeEditModal()">Cancel</button>
      </div>
    </div>
  </div>

<script src="../shared/symbols.js"></script>

  <script>
  // -------------------------
  // Application state
  // -------------------------
  const MAX_CARDS = 10;
  const cards = []; // { text, color, image }
  let selectedSampleImage = null;
  let tempPreviewImage = null;
  let editingIndex = null;

  // -------------------------
  // UI references
  // -------------------------
  const cardTextInput = document.getElementById('cardText');
  const suggestionsEl = document.getElementById('suggestions');
  const tempPreviewEl = document.getElementById('tempPreview');
  const previewEl = document.getElementById('preview');
  const sampleImagesContainer = document.getElementById('sampleImages');
  const cardCountEl = document.getElementById('cardCount');
  const cardCountWarning = document.getElementById('cardCountWarning');

  // Edit modal refs
  const editModal = document.getElementById('editModal');
  const editText = document.getElementById('editText');
  const editColor = document.getElementById('editColor');
  const editImage = document.getElementById('editImage');
  const editSampleImagesEl = document.getElementById('editSampleImages');
  const editSuggestionsEl = document.getElementById('editSuggestions');

  // -------------------------
  // Tab position calculator
  // -------------------------
  function getTabPosition(index, totalCards) {
    // Distribute tabs: symmetrical left/right, odd on bottom
    // Pattern for max 10: L(3) B(4) R(3)
    
    const leftCount = Math.floor(totalCards / 3);
    const rightCount = Math.floor(totalCards / 3);
    const bottomCount = totalCards - leftCount - rightCount;
    
    if (index < leftCount) {
      return { side: 'left', position: index };
    } else if (index < leftCount + bottomCount) {
      return { side: 'bottom', position: index - leftCount };
    } else {
      return { side: 'right', position: index - leftCount - bottomCount };
    }
  }

  // -------------------------
  // Build categories UI from library
  // -------------------------
  function buildCategoryGallery() {
    const cats = [...new Set(symbolLibrary.map(s => s.category || 'Uncategorized'))];
    sampleImagesContainer.innerHTML = '';
    cats.forEach(cat => {
      const header = document.createElement('div');
      header.className = 'categoryHeader';
      header.innerHTML = `
        <strong>${cat}</strong>
        <div>
          <button type="button" data-action="toggle" data-cat="${cat}">Collapse</button>
          <button type="button" data-action="showOnly" data-cat="${cat}" style="margin-left:6px;">Show only</button>
        </div>
      `;
      sampleImagesContainer.appendChild(header);

      const row = document.createElement('div');
      row.className = 'sample-row';
      row.dataset.category = cat;
      symbolLibrary.filter(s => (s.category||'Uncategorized') === cat).forEach(s => {
        const img = document.createElement('img');
        img.src = s.src;
        img.alt = s.name;
        img.title = s.name;
        img.dataset.name = s.name;
        img.dataset.src = s.src;
        img.dataset.category = cat;
        img.addEventListener('click', () => {
          selectedSampleImage = s.src;
          tempPreviewImage = s.src;
          highlightSample(s.src);
          updateTempPreview();
        });
        row.appendChild(img);
      });
      sampleImagesContainer.appendChild(row);

      header.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          const c = btn.dataset.cat;
          if (action === 'toggle') {
            if (row.style.display === 'none') {
              row.style.display = 'flex';
              btn.textContent = 'Collapse';
            } else {
              row.style.display = 'none';
              btn.textContent = 'Expand';
            }
          } else if (action === 'showOnly') {
            sampleImagesContainer.querySelectorAll('.sample-row').forEach(r => {
              r.style.display = (r.dataset.category === c) ? 'flex' : 'none';
            });
            sampleImagesContainer.querySelectorAll('.categoryHeader button[data-action="toggle"]').forEach(b => {
              const catb = b.dataset.cat;
              const rowb = sampleImagesContainer.querySelector(`.sample-row[data-category="${catb}"]`);
              b.textContent = (rowb.style.display === 'none') ? 'Expand' : 'Collapse';
            });
          }
        });
      });
    });

    const reset = document.createElement('div');
    reset.style.marginTop = '8px';
    reset.innerHTML = `<button onclick="resetCategoryView()">Show all categories</button> <span class="muted">(or use category buttons above)</span>`;
    sampleImagesContainer.appendChild(reset);
  }

  function resetCategoryView(){
    sampleImagesContainer.querySelectorAll('.sample-row').forEach(r => r.style.display = 'flex');
    sampleImagesContainer.querySelectorAll('.categoryHeader button[data-action="toggle"]').forEach(b => b.textContent = 'Collapse');
  }

  function populateEditSampleGallery(){
    editSampleImagesEl.innerHTML = '';
    symbolLibrary.forEach(s => {
      const thumb = document.createElement('img');
      thumb.className = 'small-thumb';
      thumb.src = s.src;
      thumb.title = s.name;
      thumb.dataset.src = s.src;
      thumb.addEventListener('click', () => {
        editImage.dataset.sample = s.src;
        editImage._uploadedData = null;
        highlightEditSample(s.src);
        updateEditModalPreview();
      });
      editSampleImagesEl.appendChild(thumb);
    });
  }

  // -------------------------
  // Suggestions (add-mode)
  // -------------------------
  cardTextInput.addEventListener('input', onTextInput);
  cardTextInput.addEventListener('focus', onTextInput);
  document.addEventListener('click', (e) => {
    if (!suggestionsEl.contains(e.target) && e.target !== cardTextInput) hideSuggestions();
  });

  function onTextInput() {
    const q = (cardTextInput.value || '').toLowerCase().trim();
    if (!q) { hideSuggestions(); updateTempPreview(); return; }

    const matches = symbolLibrary.filter(item => {
      if (item.name && item.name.toLowerCase().includes(q)) return true;
      if (item.keywords && item.keywords.some(k => k.toLowerCase().includes(q))) return true;
      return false;
    });

    if (matches.length === 0) { hideSuggestions(); updateTempPreview(); return; }

    suggestionsEl.innerHTML = '';
    matches.forEach(item => {
      const row = document.createElement('div');
      row.className = 'item';
      row.innerHTML = `<img src="${item.src}" alt="${escapeHtml(item.name)}"><div class="label">${escapeHtml(item.name)} <div style="font-size:12px;color:#666">${escapeHtml(item.category||'')}</div></div>`;
      row.onclick = () => {
        selectedSampleImage = item.src;
        tempPreviewImage = item.src;
        highlightSample(item.src);
        updateTempPreview();
        hideSuggestions();
        if (!cardTextInput.value.trim()) cardTextInput.value = item.name;
        cardTextInput.focus();
      };
      suggestionsEl.appendChild(row);
    });
    showSuggestions();
  }
  
  function showSuggestions(){ suggestionsEl.style.display = 'block'; }
  function hideSuggestions(){ suggestionsEl.style.display = 'none'; suggestionsEl.innerHTML = ''; }

  function highlightSample(src) {
    sampleImagesContainer.querySelectorAll('img').forEach(img => {
      img.style.borderColor = (img.src === src) ? '#007bff' : '#ccc';
    });
  }

  document.getElementById('cardImage').addEventListener('change', function() {
    const f = this.files && this.files[0];
    if (!f) return;
    selectedSampleImage = null;
    const reader = new FileReader();
    reader.onloadend = () => {
      tempPreviewImage = reader.result;
      highlightSample(null);
      updateTempPreview();
    };
    reader.readAsDataURL(f);
  });

  function updateTempPreview(){
    const text = document.getElementById('cardText').value.trim();
    const color = document.getElementById('cardColor').value;
    tempPreviewEl.innerHTML = '';
    if (tempPreviewImage || text) {
      const d = document.createElement('div');
      d.className = 'card';
      d.innerHTML = `
        <div style="width:100px; height:80px; display:flex; align-items:center; justify-content:center; margin:0 auto 6px;">
          ${ tempPreviewImage ? `<img src="${tempPreviewImage}" alt="preview" style="max-width:100%; max-height:100%;">` : '' }
        </div>
        <div style="color:${color};"><strong>${escapeHtml(text)}</strong></div>
      `;
      tempPreviewEl.appendChild(d);
    }
  }

  function updateCardCount() {
    cardCountEl.textContent = cards.length;
    if (cards.length >= MAX_CARDS) {
      cardCountWarning.style.display = 'inline';
    } else {
      cardCountWarning.style.display = 'none';
    }
  }

  // -------------------------
  // Add / Edit / Render cards
  // -------------------------
  function addCard() {
    if (cards.length >= MAX_CARDS) {
      alert(`Maximum ${MAX_CARDS} cards allowed!`);
      return;
    }

    const text = document.getElementById('cardText').value.trim();
    const color = document.getElementById('cardColor').value;
    const fileInput = document.getElementById('cardImage');

    if (!text) { alert('Please enter activity name.'); return; }

    if (fileInput.files.length > 0) {
      const reader = new FileReader();
      reader.onloadend = () => {
        cards.push({ text, color, image: reader.result });
        resetInputs(); renderPreview(); updateCardCount();
      };
      reader.readAsDataURL(fileInput.files[0]);
    } else if (selectedSampleImage) {
      cards.push({ text, color, image: selectedSampleImage });
      resetInputs(); renderPreview(); updateCardCount();
    } else {
      alert('Please choose an image (upload or sample).');
    }
  }

  function resetInputs(){
    document.getElementById('cardText').value = '';
    document.getElementById('cardImage').value = '';
    selectedSampleImage = null;
    tempPreviewImage = null;
    tempPreviewEl.innerHTML = '';
    highlightSample(null);
    hideSuggestions();
  }

  function renderPreview(){
    previewEl.innerHTML = '';
    cards.forEach((c,i) => {
      const tabInfo = getTabPosition(i, cards.length);
      const d = document.createElement('div');
      d.className = 'card';
      d.innerHTML = `
        <div style="width:100px; height:80px; display:flex; align-items:center; justify-content:center; margin:0 auto 6px;">
          <img src="${c.image}" alt="img" style="max-width:100%; max-height:100%;">
        </div>
        <div style="color:${c.color};"><strong>${escapeHtml(c.text)}</strong></div>
        <div style="font-size:11px; color:#666; margin-top:2px;">Tab: ${tabInfo.side}</div>
        <div style="margin-top:6px;">
          <button onclick="openEdit(${i})">Edit</button>
          <button onclick="removeCard(${i})">Remove</button>
        </div>
      `;
      previewEl.appendChild(d);
    });
  }

  function removeCard(i){ cards.splice(i,1); renderPreview(); updateCardCount(); }
  function clearCards(){ if (confirm('Clear all cards?')){ cards.length = 0; renderPreview(); updateCardCount(); } }

  new Sortable(previewEl, {
    animation: 150,
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    onEnd: function(evt) {
      const [moved] = cards.splice(evt.oldIndex, 1);
      cards.splice(evt.newIndex, 0, moved);
      renderPreview();
    }
  });

  // -------------------------
  // Edit modal logic
  // -------------------------
  populateEditSampleGallery();
  editText.addEventListener('input', onEditTextInput);
  editText.addEventListener('focus', onEditTextInput);
  document.addEventListener('click', (e) => {
    if (!editSuggestionsEl.contains(e.target) && e.target !== editText) hideEditSuggestions();
  });

  function onEditTextInput(){
    const q = (editText.value || '').toLowerCase().trim();
    if (!q) { hideEditSuggestions(); return; }

    const matches = symbolLibrary.filter(item => {
      if (item.name && item.name.toLowerCase().includes(q)) return true;
      if (item.keywords && item.keywords.some(k => k.toLowerCase().includes(q))) return true;
      return false;
    });

    if (matches.length === 0) { hideEditSuggestions(); return; }

    editSuggestionsEl.innerHTML = '';
    matches.forEach(item => {
      const row = document.createElement('div');
      row.className = 'item';
      row.innerHTML = `<img src="${item.src}" alt="${escapeHtml(item.name)}"><div class="label">${escapeHtml(item.name)}</div>`;
      row.onclick = () => {
        editImage.dataset.sample = item.src;
        editImage._uploadedData = null;
        highlightEditSample(item.src);
        hideEditSuggestions();
        if (!editText.value.trim()) editText.value = item.name;
        updateEditModalPreview();
      };
      editSuggestionsEl.appendChild(row);
    });
    editSuggestionsEl.style.display = 'block';
  }
  
  function hideEditSuggestions(){ editSuggestionsEl.style.display = 'none'; editSuggestionsEl.innerHTML = ''; }

  function openEdit(i) {
    editingIndex = i;
    const c = cards[i];
    editText.value = c.text;
    editColor.value = c.color || '#000000';
    editImage.value = '';
    editImage._uploadedData = null;
    editImage.dataset.sample = (c.image && !c.image.startsWith('data:')) ? c.image : '';
    highlightEditSample(editImage.dataset.sample || '');
    updateEditModalPreview();
    editModal.style.display = 'flex';
    editModal.setAttribute('aria-hidden', 'false');
  }

  editImage.addEventListener('change', () => {
    if (editImage.files.length > 0) {
      editImage.dataset.sample = '';
      highlightEditSample(null);
      const reader = new FileReader();
      reader.onload = (e) => {
        editImage._uploadedData = e.target.result;
        updateEditModalPreview();
      };
      reader.readAsDataURL(editImage.files[0]);
    }
  });

  function highlightEditSample(src){
    editSampleImagesEl.querySelectorAll('img').forEach(el => {
      el.style.borderColor = (el.src === src) ? '#007bff' : '#ccc';
    });
  }

  function updateEditModalPreview(){
    const text = editText.value.trim();
    const color = editColor.value;
    let imgSrc = editImage._uploadedData || editImage.dataset.sample || '';
    if (!imgSrc && editingIndex !== null && cards[editingIndex]) imgSrc = cards[editingIndex].image || '';
    const existing = document.getElementById('modalPreview');
    if (existing) existing.remove();
    const previewBox = document.createElement('div');
    previewBox.className = 'card';
    previewBox.id = 'modalPreview';
    previewBox.innerHTML = `
      <div style="width:100px; height:80px; display:flex; align-items:center; justify-content:center; margin:0 auto 6px;">
        ${ imgSrc ? `<img src="${imgSrc}" style="max-width:100%; max-height:100%;">` : '' }
      </div>
      <div style="color:${color};"><strong>${escapeHtml(text)}</strong></div>
    `;
    editModal.querySelector('.modal-content').appendChild(previewBox);
  }

  function saveEdit(){
    if (editingIndex === null) return;
    const txt = editText.value.trim();
    const col = editColor.value;
    const c = cards[editingIndex];

    if (editImage.files.length > 0 && editImage._uploadedData) {
      c.image = editImage._uploadedData;
    } else if (editImage.dataset.sample) {
      c.image = editImage.dataset.sample;
    }

    c.text = txt;
    c.color = col;
    renderPreview();
    closeEditModal();
  }

  function closeEditModal(){
    editModal.style.display = 'none';
    editModal.setAttribute('aria-hidden', 'true');
    editingIndex = null;
    editImage._uploadedData = null;
    const prev = document.getElementById('modalPreview');
    if (prev) prev.remove();
  }

  editModal.addEventListener('click', (e) => {
    if (e.target === editModal) closeEditModal();
  });

  // -------------------------
  // Image helpers for PDF
  // -------------------------
  function blobToDataURL(blob){
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  async function ensureDataURL(src) {
    if (!src) throw new Error('No image src');
    if (typeof src === 'string' && src.startsWith('data:')) return src;

    try {
      const res = await fetch(src, { mode: 'cors' });
      if (!res.ok) throw new Error('Fetch failed: ' + res.status);
      const blob = await res.blob();
      return await blobToDataURL(blob);
    } catch (err) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = () => reject(new Error('Could not load image: ' + src));
        img.src = src;
      });
    }
  }

  function loadImageFromDataURL(dataURL) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Image load error'));
      img.src = dataURL;
    });
  }

  // -------------------------
  // PDF generation
  // -------------------------
  async function generatePDF() {
    const loadingOverlay = document.createElement("div");
    loadingOverlay.style.cssText = "position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:10000;";
    loadingOverlay.innerHTML = '<div style="color:white;font-size:1.2em;">Generating PDF, please wait...</div>';
    document.body.appendChild(loadingOverlay);

    try {
      if (cards.length === 0) {
        alert("No cards to generate.");
        loadingOverlay.remove();
        return;
      }

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF("p", "mm", "a4");
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();

      const cardW = 80;
      const cardH = 60;
      const baseTabSize = 20;
      const cornerRadius = 5;
      const margin = 10;
      const holeRadius = 3;

      // Preload all images
      const imagePromises = cards.map(async (c) => {
        try {
          const dataURL = await ensureDataURL(c.image);
          const img = await loadImageFromDataURL(dataURL);
          return { ...c, dataURL, img };
        } catch (err) {
          console.warn("Image load failed:", c.text, err);
          return { ...c, dataURL: null, img: null };
        }
      });

      const loadedCards = await Promise.all(imagePromises);

      // Calculate tab distributions
      const totalCards = loadedCards.length;
      const leftCount = Math.floor(totalCards / 3);
      const rightCount = Math.floor(totalCards / 3);
      const bottomCount = totalCards - leftCount - rightCount;

      // Calculate tab sizes (expand to fill space)
      const leftTabH = leftCount > 0 ? cardH / leftCount : baseTabSize;
      const rightTabH = rightCount > 0 ? cardH / rightCount : baseTabSize;
      const bottomTabW = bottomCount > 0 ? cardW / bottomCount : baseTabSize;

      // Draw each card
      let x = margin, y = margin;

      for (let i = 0; i < loadedCards.length; i++) {
        const c = loadedCards[i];
        const tabInfo = getTabPosition(i, totalCards);
        
        // Calculate total width and height including tab
        let totalW = cardW;
        let totalH = cardH;
        let tabX = 0, tabY = 0, tabW = 0, tabH = 0;
        let cardX = x; // Main card X position (adjusted for left tabs)

        if (tabInfo.side === 'left') {
          totalW = cardW + baseTabSize;
          tabW = baseTabSize;
          tabH = leftTabH;
          tabX = x;
          tabY = y + (tabInfo.position * leftTabH);
          cardX = x + baseTabSize; // Card starts AFTER the tab
        } else if (tabInfo.side === 'right') {
          totalW = cardW + baseTabSize;
          tabW = baseTabSize;
          tabH = rightTabH;
          tabX = x + cardW;
          tabY = y + (tabInfo.position * rightTabH);
          cardX = x; // Card at normal position
        } else { // bottom
          totalH = cardH + baseTabSize;
          tabW = bottomTabW;
          tabH = baseTabSize;
          tabX = x + (tabInfo.position * bottomTabW);
          tabY = y + cardH;
          cardX = x; // Card at normal position
        }

        // Check if card fits on page, if not create new page
        if (x + totalW > pageW - margin) {
          x = margin;
          y += 100; // Move down
        }
        if (y + totalH > pageH - margin) {
          doc.addPage();
          x = margin;
          y = margin;
        }

        // Recalculate positions after potential page change
        if (tabInfo.side === 'left') {
          tabX = x;
          tabY = y + (tabInfo.position * leftTabH);
          cardX = x + baseTabSize;
        } else if (tabInfo.side === 'right') {
          tabX = x + cardW;
          tabY = y + (tabInfo.position * rightTabH);
          cardX = x;
        } else {
          tabX = x + (tabInfo.position * bottomTabW);
          tabY = y + cardH;
          cardX = x;
        }

        // Draw main card body (use cardX instead of x)
        doc.setDrawColor(0);
        doc.setLineWidth(0.5);
        doc.rect(cardX, y, cardW, cardH);

        // Draw tab
        doc.rect(tabX, tabY, tabW, tabH);

        // Draw hole punch at top center of main card (use cardX)
        const holeX = cardX + cardW / 2;
        const holeY = y + 5;
        doc.setDrawColor(180);
        doc.circle(holeX, holeY, holeRadius, "S");
        doc.setDrawColor(0);

        // Draw image on main card (use cardX, moved down from hole punch, larger)
        if (c.img && c.dataURL) {
          const imgMaxW = cardW - 8; // Slightly larger (was 10)
          const imgMaxH = cardH - 28; // Leave room for text
          const aspect = c.img.naturalWidth / c.img.naturalHeight;
          let drawW = imgMaxW, drawH = imgMaxH;
          if (drawW / drawH > aspect) drawW = drawH * aspect;
          else drawH = drawW / aspect;

          const drawX = cardX + (cardW - drawW) / 2;
          const drawY = y + 12; // Moved down to give space from hole

          let fmt = "PNG";
          if (c.dataURL.startsWith("data:image/jpeg")) fmt = "JPEG";
          else if (c.dataURL.startsWith("data:image/webp")) fmt = "WEBP";

          doc.addImage(c.dataURL, fmt, drawX, drawY, drawW, drawH);
        }

        // Draw text on main card (use cardX, bottom, moved down slightly)
        doc.setFontSize(10);
        doc.setTextColor(c.color || "#000000");
        const textLines = doc.splitTextToSize(c.text, cardW - 8);
        doc.text(textLines, cardX + cardW / 2, y + cardH - 6, { align: "center" });

        // Draw image on tab (centered, fixed size)
        if (c.img && c.dataURL) {
          const tabImgSize = 14; // Image size
          const aspect = c.img.naturalWidth / c.img.naturalHeight;
          let tabImgW = tabImgSize, tabImgH = tabImgSize;
          if (aspect > 1) tabImgH = tabImgSize / aspect;
          else tabImgW = tabImgSize * aspect;

          let tabImgX, tabImgY;
          
          if (tabInfo.side === 'left' || tabInfo.side === 'right') {
            // For side tabs, center both horizontally and vertically
            tabImgX = tabX + (tabW - tabImgW) / 2;
            // Center vertically in the tab, accounting for text below, with small padding from top
            const contentHeight = tabImgH + 6; // image + gap + text height
            tabImgY = tabY + (tabH - contentHeight) / 2 + 1; // Added 1mm padding from top
          } else {
            // For bottom tabs, center horizontally and position at top
            tabImgX = tabX + (tabW - tabImgW) / 2;
            tabImgY = tabY + 2;
          }

          let fmt = "PNG";
          if (c.dataURL.startsWith("data:image/jpeg")) fmt = "JPEG";
          else if (c.dataURL.startsWith("data:image/webp")) fmt = "WEBP";

          doc.addImage(c.dataURL, fmt, tabImgX, tabImgY, tabImgW, tabImgH);
        }

        // Draw text on tab (horizontal, positioned below image)
        doc.setFontSize(6);
        doc.setTextColor(c.color || "#000000");
        
        if (tabInfo.side === 'left' || tabInfo.side === 'right') {
          // Horizontal text below image for side tabs, vertically centered
          const truncatedText = c.text.length > 6 ? c.text.substring(0, 5) + '.' : c.text;
          const contentHeight = 14 + 6; // image height + gap + text
          const textY = tabY + (tabH - contentHeight) / 2 + 14 + 4 + 1; // Added 1mm to match image adjustment
          doc.text(truncatedText, tabX + tabW / 2, textY, { align: 'center' });
        } else {
          // Bottom tab - horizontal text below image
          const truncatedText = c.text.length > 8 ? c.text.substring(0, 6) + '..' : c.text;
          doc.text(truncatedText, tabX + tabW / 2, tabY + 18, { align: 'center' });
        }

        // Move to next position
        x += totalW + margin;
        if (x + totalW > pageW - margin) {
          x = margin;
          y += 100;
        }
      }

      doc.save("tabbed-lanyard-cards.pdf");
      
      loadingOverlay.innerHTML = '<div style="color:white;font-size:1.2em;">âœ… PDF generated successfully!</div>';
      setTimeout(() => loadingOverlay.remove(), 1500);
      
    } catch (error) {
      console.error("PDF generation error:", error);
      loadingOverlay.remove();
      alert("Failed to generate PDF: " + error.message + "\n\nPlease check the browser console for details.");
    }
  }

  // -------------------------
  // Utilities & init
  // -------------------------
  function escapeHtml(s) {
    if (s === undefined || s === null) return '';
    return String(s).replace(/[&<>"']/g, (c) => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
  }

  function filterCategory(cat) {
    if (cat === 'all') {
      resetCategoryView();
      return;
    }
    sampleImagesContainer.querySelectorAll('.sample-row').forEach(r => {
      r.style.display = (r.dataset.category === cat) ? 'flex' : 'none';
    });
  }

  // Expose functions to global scope
  window.filterCategory = filterCategory;
  window.addCard = addCard;
  window.generatePDF = generatePDF;
  window.clearCards = clearCards;
  window.openEdit = openEdit;
  window.removeCard = removeCard;
  window.saveEdit = saveEdit;
  window.closeEditModal = closeEditModal;
  window.resetCategoryView = resetCategoryView;

  // Initialize
  buildCategoryGallery();
  populateEditSampleGallery();
  renderPreview();
  updateCardCount();

  </script>

</body>
</html>